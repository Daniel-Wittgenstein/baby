window.$__$runtimeData = {"code":"var $$__engX082398 = function(exports) {\n  \"use strict\";\n  const arithmeticCommands = {\n    set: (a, b) => b,\n    incr: (a, b) => a + b,\n    decr: (a, b) => a - b,\n    mult: (a, b) => a * b,\n    div: (a, b) => a / b,\n    round: (a, b) => Math.round(a),\n    floor: (a, b) => Math.floor(a)\n  };\n  exports.arithmeticCommands = arithmeticCommands;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  function customConfirm(title, msg, confirmButtonText, cancelButtonText, onConfirm, onCancel) {\n    const overlay = document.createElement(\"div\");\n    overlay.className = \"confirm-overlay show\";\n    const modal = document.createElement(\"div\");\n    modal.className = \"confirm-modal show\";\n    const titleEl = document.createElement(\"h2\");\n    titleEl.textContent = title;\n    const msgEl = document.createElement(\"p\");\n    msgEl.textContent = msg;\n    const buttonsContainer = document.createElement(\"div\");\n    buttonsContainer.className = \"confirm-buttons\";\n    const confirmBtn = document.createElement(\"button\");\n    confirmBtn.textContent = confirmButtonText;\n    confirmBtn.className = \"confirm-button\";\n    const cancelBtn = document.createElement(\"button\");\n    cancelBtn.textContent = cancelButtonText;\n    cancelBtn.className = \"cancel-button\";\n    const closeModal = (callback) => {\n      overlay.classList.remove(\"show\");\n      modal.classList.remove(\"show\");\n      overlay.classList.add(\"hide\");\n      modal.classList.add(\"hide\");\n      setTimeout(() => {\n        if (document.body.contains(overlay)) {\n          document.body.removeChild(overlay);\n        }\n        callback();\n      }, 300);\n    };\n    confirmBtn.onclick = () => closeModal(onConfirm);\n    cancelBtn.onclick = () => closeModal(onCancel);\n    buttonsContainer.appendChild(confirmBtn);\n    buttonsContainer.appendChild(cancelBtn);\n    modal.appendChild(titleEl);\n    modal.appendChild(msgEl);\n    modal.appendChild(buttonsContainer);\n    overlay.appendChild(modal);\n    document.body.appendChild(overlay);\n  }\n  exports.customConfirm = customConfirm;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  var LineType = /* @__PURE__ */ ((LineType2) => {\n    LineType2[\"Gather\"] = \"Gather\";\n    LineType2[\"Choice\"] = \"Choice\";\n    LineType2[\"Undecided\"] = \"Undecided\";\n    return LineType2;\n  })(LineType || {});\n  function getFirstWordAndRest(str) {\n    const index = str.search(/\\s/);\n    if (index === -1)\n      return [str.trim(), \"\"];\n    return [str.slice(0, index).trim(), str.slice(index + 1).trim()];\n  }\n  function removeFirstChar(str) {\n    return str.slice(1);\n  }\n  function userError(text, lineNo) {\n    document.body.innerHTML = `<div class=\"user-error\">LINE ${lineNo}: ${text}</div>`;\n    throw new Error(text);\n  }\n  function hasLabelStartText(text) {\n    return text.startsWith(\"label\") || text.startsWith(\"l\");\n  }\n  const arithmeticCommands = {\n    set: (a, b) => b,\n    incr: (a, b) => a + b,\n    decr: (a, b) => a - b,\n    mult: (a, b) => a * b,\n    div: (a, b) => a / b,\n    round: (a, b) => Math.round(a),\n    floor: (a, b) => Math.floor(a)\n  };\n  function extractLabelAndCommandInfo(storyLines) {\n    const targetTable = {};\n    const commandTable = [];\n    function validateCommand(name, text, orgNo) {\n      if (name === \"goto\") {\n        const labelName = text;\n        if (!doesLabelExist(labelName)) {\n          userError(`\".goto ${labelName}\", but there is no label with name \"${labelName}\"`, orgNo);\n        }\n        return true;\n      }\n      if (arithmeticCommands[name]) {\n        return true;\n      }\n      return false;\n    }\n    function doesLabelExist(name) {\n      const index = getLabelIndex(name);\n      return index || index === 0;\n    }\n    function getLabelIndex(name) {\n      return targetTable[name];\n    }\n    function addLabel(index, name) {\n      name = name.toLowerCase();\n      targetTable[name] = index;\n    }\n    function addCommand(index, commandName, text, orgNo) {\n      commandTable[index] = {\n        name: commandName,\n        text\n      };\n      if (!validateCommand(commandName, text, orgNo)) {\n        userError(\n          `\".${commandName}\" is not a valid command. If you wanted to create a choice, put a space after the dot.`,\n          orgNo\n        );\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type === LineType.Undecided) {\n        if (!line.text.startsWith(\".\"))\n          continue;\n        const text = removeFirstChar(line.text);\n        if (hasLabelStartText(text)) {\n          const [_, name] = getFirstWordAndRest(text);\n          addLabel(line.index, name);\n          continue;\n        }\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type !== LineType.Undecided || !line.text.startsWith(\".\"))\n        continue;\n      const text = removeFirstChar(line.text);\n      if (hasLabelStartText(text))\n        continue;\n      let [commandName, rest] = getFirstWordAndRest(text);\n      commandName = commandName.toLowerCase();\n      addCommand(line.index, commandName, rest, line.orgCodeLineNo);\n    }\n    return {\n      targetTable,\n      commandTable\n    };\n  }\n  exports.extractLabelAndCommandInfo = extractLabelAndCommandInfo;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  function hasLabelStartText(text) {\n    return text.startsWith(\"label\") || text.startsWith(\"l\");\n  }\n  exports.hasLabelStartText = hasLabelStartText;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function() {\n  \"use strict\";\n  const i18n = {\n    light: \"Light\",\n    dark: \"Dark\",\n    animsOn: \"Animations On\",\n    animsOff: \"Animations Off\",\n    rlyRestartTitle: \"Restart?\",\n    rlyRestartText: \"Do you really want to restart the story? Your progress will be lost.\",\n    rlyRestartOk: \"Yes, restart!\",\n    rlyRestartCancel: \"Cancel\"\n  };\n  return i18n;\n}();\n\nvar $$__engX082398 = function() {\n  \"use strict\";\n  const icons = {\n    //iconoir\n    hamburger: `data:image/svg+xml;utf8,` + encodeURIComponent(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg width=\"24px\" height=\"24px\" stroke-width=\"1.5\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" color=\"#000000\"><path d=\"M3 5H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M3 12H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M3 19H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`)\n  };\n  return icons;\n}();\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  var Theme = /* @__PURE__ */ ((Theme2) => {\n    Theme2[\"Undecided\"] = \"Undecided\";\n    Theme2[\"Light\"] = \"Light\";\n    Theme2[\"Dark\"] = \"Dark\";\n    return Theme2;\n  })(Theme || {});\n  const USER_SETTINGS_KEY = \"user-settings\";\n  const DEFAULT_SETTINGS = {\n    theme: Theme.Light\n  };\n  function loadUserSettings() {\n    let data = localStorage.getItem(USER_SETTINGS_KEY);\n    if (data) {\n      try {\n        data = JSON.parse(data);\n      } catch {\n        console.log(\"No user settings stored.\");\n        data = null;\n      }\n    }\n    if (data) {\n      return JSON.parse(data);\n    } else {\n      return DEFAULT_SETTINGS;\n    }\n  }\n  function saveUserSettings(settings) {\n    localStorage.setItem(USER_SETTINGS_KEY, JSON.stringify(settings));\n  }\n  exports.loadUserSettings = loadUserSettings;\n  exports.saveUserSettings = saveUserSettings;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n  var _lines, _targetTable, _commandTable, _linePointer, _currentChoices, _callbacks, _checkIfCond, checkIfCond_fn, _isNextLineAChoice, isNextLineAChoice_fn, _execCommand, execCommand_fn, _execChoice, execChoice_fn, _execText, execText_fn, _execLine, execLine_fn;\n  var ActionType = /* @__PURE__ */ ((ActionType2) => {\n    ActionType2[\"Text\"] = \"Text\";\n    ActionType2[\"Choice\"] = \"Choice\";\n    ActionType2[\"Command\"] = \"Command\";\n    ActionType2[\"Nothing\"] = \"Nothing\";\n    ActionType2[\"EndOfTurn\"] = \"EndOfTurn\";\n    ActionType2[\"StoryFlowRunsOut\"] = \"StoryFlowRunsOut\";\n    return ActionType2;\n  })(ActionType || {});\n  var LineType = /* @__PURE__ */ ((LineType2) => {\n    LineType2[\"Gather\"] = \"Gather\";\n    LineType2[\"Choice\"] = \"Choice\";\n    LineType2[\"Undecided\"] = \"Undecided\";\n    return LineType2;\n  })(LineType || {});\n  function getFirstWordAndRest(str) {\n    const index = str.search(/\\s/);\n    if (index === -1)\n      return [str.trim(), \"\"];\n    return [str.slice(0, index).trim(), str.slice(index + 1).trim()];\n  }\n  function removeFirstChar(str) {\n    return str.slice(1);\n  }\n  function userError(text, lineNo) {\n    document.body.innerHTML = `<div class=\"user-error\">LINE ${lineNo}: ${text}</div>`;\n    throw new Error(text);\n  }\n  function hasLabelStartText(text) {\n    return text.startsWith(\"label\") || text.startsWith(\"l\");\n  }\n  const arithmeticCommands = {\n    set: (a, b) => b,\n    incr: (a, b) => a + b,\n    decr: (a, b) => a - b,\n    mult: (a, b) => a * b,\n    div: (a, b) => a / b,\n    round: (a, b) => Math.round(a),\n    floor: (a, b) => Math.floor(a)\n  };\n  function extractLabelAndCommandInfo(storyLines) {\n    const targetTable = {};\n    const commandTable = [];\n    function validateCommand(name, text, orgNo) {\n      if (name === \"goto\") {\n        const labelName = text;\n        if (!doesLabelExist(labelName)) {\n          userError(`\".goto ${labelName}\", but there is no label with name \"${labelName}\"`, orgNo);\n        }\n        return true;\n      }\n      if (arithmeticCommands[name]) {\n        return true;\n      }\n      return false;\n    }\n    function doesLabelExist(name) {\n      const index = getLabelIndex(name);\n      return index || index === 0;\n    }\n    function getLabelIndex(name) {\n      return targetTable[name];\n    }\n    function addLabel(index, name) {\n      name = name.toLowerCase();\n      targetTable[name] = index;\n    }\n    function addCommand(index, commandName, text, orgNo) {\n      commandTable[index] = {\n        name: commandName,\n        text\n      };\n      if (!validateCommand(commandName, text, orgNo)) {\n        userError(\n          `\".${commandName}\" is not a valid command. If you wanted to create a choice, put a space after the dot.`,\n          orgNo\n        );\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type === LineType.Undecided) {\n        if (!line.text.startsWith(\".\"))\n          continue;\n        const text = removeFirstChar(line.text);\n        if (hasLabelStartText(text)) {\n          const [_, name] = getFirstWordAndRest(text);\n          addLabel(line.index, name);\n          continue;\n        }\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type !== LineType.Undecided || !line.text.startsWith(\".\"))\n        continue;\n      const text = removeFirstChar(line.text);\n      if (hasLabelStartText(text))\n        continue;\n      let [commandName, rest] = getFirstWordAndRest(text);\n      commandName = commandName.toLowerCase();\n      addCommand(line.index, commandName, rest, line.orgCodeLineNo);\n    }\n    return {\n      targetTable,\n      commandTable\n    };\n  }\n  class Runner {\n    constructor(storyLines, callbacks) {\n      __privateAdd(this, _checkIfCond);\n      __privateAdd(this, _isNextLineAChoice);\n      __privateAdd(this, _execCommand);\n      __privateAdd(this, _execChoice);\n      __privateAdd(this, _execText);\n      __privateAdd(this, _execLine);\n      __privateAdd(this, _lines, void 0);\n      __privateAdd(this, _targetTable, {});\n      __privateAdd(this, _commandTable, []);\n      __privateAdd(this, _linePointer, 0);\n      __privateAdd(this, _currentChoices, []);\n      __privateAdd(this, _callbacks, void 0);\n      __privateSet(this, _lines, storyLines);\n      const { targetTable, commandTable } = extractLabelAndCommandInfo(__privateGet(this, _lines));\n      __privateSet(this, _targetTable, targetTable);\n      __privateSet(this, _commandTable, commandTable);\n      __privateSet(this, _callbacks, callbacks);\n    }\n    restartStory() {\n      __privateSet(this, _linePointer, 0);\n      __privateSet(this, _currentChoices, []);\n    }\n    processNextLine() {\n      if (__privateGet(this, _currentChoices).length > 0 && !__privateMethod(this, _isNextLineAChoice, isNextLineAChoice_fn).call(this)) {\n        return {\n          type: ActionType.EndOfTurn,\n          text: \"\",\n          lineNo: -1\n        };\n      }\n      const { action, nextLine } = __privateMethod(this, _execLine, execLine_fn).call(this, __privateGet(this, _linePointer));\n      __privateSet(this, _linePointer, nextLine);\n      return action;\n    }\n    chooseChoice(index) {\n      const choice = __privateGet(this, _currentChoices)[index];\n      if (!choice) {\n        throw new Error(`Fatal: choice with index ${index} does not exist.`);\n      }\n      __privateSet(this, _currentChoices, []);\n      __privateSet(this, _linePointer, choice.index + 1);\n    }\n  }\n  _lines = new WeakMap();\n  _targetTable = new WeakMap();\n  _commandTable = new WeakMap();\n  _linePointer = new WeakMap();\n  _currentChoices = new WeakMap();\n  _callbacks = new WeakMap();\n  _checkIfCond = new WeakSet();\n  checkIfCond_fn = function(line) {\n    if (__privateGet(this, _callbacks).onCheckIfCond(\n      line.ifProps.left,\n      line.ifProps.operator,\n      line.ifProps.right\n    )) {\n      return line.index + 1;\n    } else {\n      return line.nextLineIndex;\n    }\n  };\n  _isNextLineAChoice = new WeakSet();\n  isNextLineAChoice_fn = function() {\n    var _a;\n    return !!(((_a = __privateGet(this, _lines)[__privateGet(this, _linePointer)]) == null ? void 0 : _a.type) === LineType.Choice);\n  };\n  _execCommand = new WeakSet();\n  execCommand_fn = function(command, index, line) {\n    if (command.name === \"goto\") {\n      const target = command.text.toLowerCase();\n      const nextLine = __privateGet(this, _targetTable)[target];\n      return {\n        nextLine,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    return {\n      nextLine: index + 1,\n      action: {\n        type: ActionType.Command,\n        text: command.text,\n        commandName: command.name,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n  };\n  _execChoice = new WeakSet();\n  execChoice_fn = function(line) {\n    const result = {\n      nextLine: line.nextLineIndex || line.index + 1,\n      action: {\n        type: ActionType.Choice,\n        text: line.text,\n        choiceIndex: __privateGet(this, _currentChoices).length,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n    __privateGet(this, _currentChoices).push(line);\n    return result;\n  };\n  _execText = new WeakSet();\n  execText_fn = function(line) {\n    return {\n      nextLine: line.nextLineIndex || line.index + 1,\n      action: {\n        type: ActionType.Text,\n        text: line.text,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n  };\n  _execLine = new WeakSet();\n  execLine_fn = function(index) {\n    const line = __privateGet(this, _lines)[index];\n    if (!line) {\n      return {\n        nextLine: 0,\n        action: {\n          type: ActionType.StoryFlowRunsOut,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (__privateGet(this, _commandTable)[line.index]) {\n      return __privateMethod(this, _execCommand, execCommand_fn).call(this, __privateGet(this, _commandTable)[line.index], line.index, line);\n    }\n    if (line.isEnd) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.isElse) {\n      return {\n        nextLine: line.nextLineIndex,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.isIfCondition) {\n      const nextLine = __privateMethod(this, _checkIfCond, checkIfCond_fn).call(this, line);\n      return {\n        nextLine,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.type === LineType.Choice) {\n      return __privateMethod(this, _execChoice, execChoice_fn).call(this, line);\n    }\n    if (line.type === LineType.Gather) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (hasLabelStartText(removeFirstChar(line.text))) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    return __privateMethod(this, _execText, execText_fn).call(this, line);\n  };\n  exports.Runner = Runner;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  var AbstractRenderElType = /* @__PURE__ */ ((AbstractRenderElType2) => {\n    AbstractRenderElType2[\"Text\"] = \"Text\";\n    AbstractRenderElType2[\"Choice\"] = \"Choice\";\n    return AbstractRenderElType2;\n  })(AbstractRenderElType || {});\n  var ActionType = /* @__PURE__ */ ((ActionType2) => {\n    ActionType2[\"Text\"] = \"Text\";\n    ActionType2[\"Choice\"] = \"Choice\";\n    ActionType2[\"Command\"] = \"Command\";\n    ActionType2[\"Nothing\"] = \"Nothing\";\n    ActionType2[\"EndOfTurn\"] = \"EndOfTurn\";\n    ActionType2[\"StoryFlowRunsOut\"] = \"StoryFlowRunsOut\";\n    return ActionType2;\n  })(ActionType || {});\n  exports.AbstractRenderElType = AbstractRenderElType;\n  exports.ActionType = ActionType;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n  var _tick, tick_fn, _execEvent, execEvent_fn;\n  class Scheduler {\n    constructor(intervalTime = 50) {\n      __privateAdd(this, _tick);\n      __privateAdd(this, _execEvent);\n      __publicField(this, \"interval\");\n      __publicField(this, \"queue\", []);\n      __publicField(this, \"currentEvent\", null);\n      this.interval = window.setInterval(() => {\n        __privateMethod(this, _tick, tick_fn).call(this);\n      }, intervalTime);\n      __privateMethod(this, _tick, tick_fn).call(this);\n    }\n    addToQueue(execFunc, delay) {\n      let time = 0;\n      if (this.queue.length === 0) {\n        time = performance.now() + delay;\n      } else {\n        time = this.queue[this.queue.length - 1].time + delay;\n      }\n      performance.now();\n      this.queue.push({\n        execFunc,\n        time\n      });\n    }\n    flushQueue() {\n      this.queue = [];\n    }\n  }\n  _tick = new WeakSet();\n  tick_fn = function() {\n    if (this.queue.length === 0 && !this.currentEvent) {\n      return;\n    }\n    if (!this.currentEvent) {\n      this.currentEvent = this.queue.shift();\n    }\n    if (performance.now() >= this.currentEvent.time) {\n      __privateMethod(this, _execEvent, execEvent_fn).call(this, this.currentEvent);\n      this.currentEvent = null;\n    }\n  };\n  _execEvent = new WeakSet();\n  execEvent_fn = function(ev) {\n    ev.execFunc();\n  };\n  exports.Scheduler = Scheduler;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  const i18n = {\n    light: \"Light\",\n    dark: \"Dark\"\n  };\n  const DEFAULT_COLOR = \"monochrome\";\n  var Theme = /* @__PURE__ */ ((Theme2) => {\n    Theme2[\"Undecided\"] = \"Undecided\";\n    Theme2[\"Light\"] = \"Light\";\n    Theme2[\"Dark\"] = \"Dark\";\n    return Theme2;\n  })(Theme || {});\n  const accentColors = {\n    monochrome: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#444\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#bbb\" }\n    },\n    red: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#9f0712\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#9f0712\" }\n    },\n    blue: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#0084d1\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#0084d1\" }\n    },\n    pink: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#e60076\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#e60076\" }\n    },\n    green: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#008236\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#008236\" }\n    }\n  };\n  const themes = {\n    [\n      \"Light\"\n      /* Light */\n    ]: {\n      fg: \"#000\",\n      bg: \"#fff\"\n    },\n    [\n      \"Dark\"\n      /* Dark */\n    ]: {\n      fg: \"#fff\",\n      bg: \"#222\"\n    }\n  };\n  let currentAccentColor = DEFAULT_COLOR;\n  let currentTheme = \"Light\";\n  function prefersDarkMode() {\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n  }\n  function prefersLightMode() {\n    return window.matchMedia(\"(prefers-color-scheme: light)\");\n  }\n  function decideTheme(authorSetTheme, userSettingsTheme) {\n    if (userSettingsTheme && (userSettingsTheme === \"Light\" || userSettingsTheme === \"Dark\")) {\n      return userSettingsTheme;\n    }\n    if (prefersLightMode())\n      return \"Light\";\n    if (prefersDarkMode())\n      return \"Dark\";\n    if (authorSetTheme === \"Light\")\n      return \"Light\";\n    if (authorSetTheme === \"Dark\")\n      return \"Dark\";\n    return \"Light\";\n  }\n  function setVar(prop, val) {\n    document.documentElement.style.setProperty(\"--\" + prop, val);\n  }\n  function switchTheme() {\n    applyTheme(\n      currentTheme === \"Light\" ? \"Dark\" : \"Light\"\n      /* Light */\n    );\n  }\n  function applyTheme(theme) {\n    const bg = themes[theme].bg;\n    const fg = themes[theme].fg;\n    setVar(\"bg\", bg);\n    setVar(\"text\", fg);\n    if (theme === \"Dark\") {\n      document.body.classList.add(\"dark\");\n    } else {\n      document.body.classList.remove(\"dark\");\n    }\n    currentTheme = theme;\n    const text = currentTheme === \"Light\" ? i18n.light : i18n.dark;\n    document.getElementById(\"menu-theme\").innerHTML = text;\n    refreshAccentColor();\n  }\n  function refreshAccentColor() {\n    const theme = currentTheme;\n    const color = currentAccentColor;\n    let targetCol = \"\";\n    if (!accentColors[color]) {\n      targetCol = accentColors[DEFAULT_COLOR][theme].std;\n    } else {\n      targetCol = accentColors[color][theme].std;\n    }\n    setVar(\"accent\", targetCol);\n  }\n  function setColors(authorSetColor, authorSetTheme, userSettingsTheme) {\n    currentAccentColor = authorSetColor;\n    const theme = decideTheme(authorSetTheme, userSettingsTheme);\n    applyTheme(theme);\n  }\n  exports.Theme = Theme;\n  exports.setColors = setColors;\n  exports.switchTheme = switchTheme;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n(function() {\n  \"use strict\";\n  var _lines, _targetTable, _commandTable, _linePointer, _currentChoices, _callbacks, _checkIfCond, checkIfCond_fn, _isNextLineAChoice, isNextLineAChoice_fn, _execCommand, execCommand_fn, _execChoice, execChoice_fn, _execText, execText_fn, _execLine, execLine_fn, _tick, tick_fn, _execEvent, execEvent_fn;\n  const i18n = {\n    light: \"Light\",\n    dark: \"Dark\",\n    animsOn: \"Animations On\",\n    animsOff: \"Animations Off\",\n    rlyRestartTitle: \"Restart?\",\n    rlyRestartText: \"Do you really want to restart the story? Your progress will be lost.\",\n    rlyRestartOk: \"Yes, restart!\",\n    rlyRestartCancel: \"Cancel\"\n  };\n  const DEFAULT_COLOR = \"monochrome\";\n  var Theme = /* @__PURE__ */ ((Theme2) => {\n    Theme2[\"Undecided\"] = \"Undecided\";\n    Theme2[\"Light\"] = \"Light\";\n    Theme2[\"Dark\"] = \"Dark\";\n    return Theme2;\n  })(Theme || {});\n  const accentColors = {\n    monochrome: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#444\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#bbb\" }\n    },\n    red: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#9f0712\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#9f0712\" }\n    },\n    blue: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#0084d1\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#0084d1\" }\n    },\n    pink: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#e60076\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#e60076\" }\n    },\n    green: {\n      [\n        \"Light\"\n        /* Light */\n      ]: { std: \"#008236\" },\n      [\n        \"Dark\"\n        /* Dark */\n      ]: { std: \"#008236\" }\n    }\n  };\n  const themes = {\n    [\n      \"Light\"\n      /* Light */\n    ]: {\n      fg: \"#000\",\n      bg: \"#fff\"\n    },\n    [\n      \"Dark\"\n      /* Dark */\n    ]: {\n      fg: \"#fff\",\n      bg: \"#222\"\n    }\n  };\n  let currentAccentColor = DEFAULT_COLOR;\n  let currentTheme = \"Light\";\n  function prefersDarkMode() {\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n  }\n  function prefersLightMode() {\n    return window.matchMedia(\"(prefers-color-scheme: light)\");\n  }\n  function decideTheme(authorSetTheme, userSettingsTheme) {\n    if (userSettingsTheme && (userSettingsTheme === \"Light\" || userSettingsTheme === \"Dark\")) {\n      return userSettingsTheme;\n    }\n    if (prefersLightMode())\n      return \"Light\";\n    if (prefersDarkMode())\n      return \"Dark\";\n    if (authorSetTheme === \"Light\")\n      return \"Light\";\n    if (authorSetTheme === \"Dark\")\n      return \"Dark\";\n    return \"Light\";\n  }\n  function setVar(prop, val) {\n    document.documentElement.style.setProperty(\"--\" + prop, val);\n  }\n  function switchTheme() {\n    applyTheme(\n      currentTheme === \"Light\" ? \"Dark\" : \"Light\"\n      /* Light */\n    );\n  }\n  function applyTheme(theme) {\n    const bg = themes[theme].bg;\n    const fg = themes[theme].fg;\n    setVar(\"bg\", bg);\n    setVar(\"text\", fg);\n    if (theme === \"Dark\") {\n      document.body.classList.add(\"dark\");\n    } else {\n      document.body.classList.remove(\"dark\");\n    }\n    currentTheme = theme;\n    const text = currentTheme === \"Light\" ? i18n.light : i18n.dark;\n    document.getElementById(\"menu-theme\").innerHTML = text;\n    refreshAccentColor();\n  }\n  function refreshAccentColor() {\n    const theme = currentTheme;\n    const color = currentAccentColor;\n    let targetCol = \"\";\n    if (!accentColors[color]) {\n      targetCol = accentColors[DEFAULT_COLOR][theme].std;\n    } else {\n      targetCol = accentColors[color][theme].std;\n    }\n    setVar(\"accent\", targetCol);\n  }\n  function setColors(authorSetColor, authorSetTheme, userSettingsTheme) {\n    currentAccentColor = authorSetColor;\n    const theme = decideTheme(authorSetTheme, userSettingsTheme);\n    applyTheme(theme);\n  }\n  const USER_SETTINGS_KEY = \"user-settings\";\n  const DEFAULT_SETTINGS = {\n    theme: Theme.Light\n  };\n  function loadUserSettings() {\n    let data = localStorage.getItem(USER_SETTINGS_KEY);\n    if (data) {\n      try {\n        data = JSON.parse(data);\n      } catch {\n        console.log(\"No user settings stored.\");\n        data = null;\n      }\n    }\n    if (data) {\n      return JSON.parse(data);\n    } else {\n      return DEFAULT_SETTINGS;\n    }\n  }\n  var AbstractRenderElType = /* @__PURE__ */ ((AbstractRenderElType2) => {\n    AbstractRenderElType2[\"Text\"] = \"Text\";\n    AbstractRenderElType2[\"Choice\"] = \"Choice\";\n    return AbstractRenderElType2;\n  })(AbstractRenderElType || {});\n  var ActionType = /* @__PURE__ */ ((ActionType2) => {\n    ActionType2[\"Text\"] = \"Text\";\n    ActionType2[\"Choice\"] = \"Choice\";\n    ActionType2[\"Command\"] = \"Command\";\n    ActionType2[\"Nothing\"] = \"Nothing\";\n    ActionType2[\"EndOfTurn\"] = \"EndOfTurn\";\n    ActionType2[\"StoryFlowRunsOut\"] = \"StoryFlowRunsOut\";\n    return ActionType2;\n  })(ActionType || {});\n  var LineType = /* @__PURE__ */ ((LineType2) => {\n    LineType2[\"Gather\"] = \"Gather\";\n    LineType2[\"Choice\"] = \"Choice\";\n    LineType2[\"Undecided\"] = \"Undecided\";\n    return LineType2;\n  })(LineType || {});\n  function getFirstWordAndRest(str) {\n    const index = str.search(/\\s/);\n    if (index === -1)\n      return [str.trim(), \"\"];\n    return [str.slice(0, index).trim(), str.slice(index + 1).trim()];\n  }\n  function removeFirstChar(str) {\n    return str.slice(1);\n  }\n  function userError(text, lineNo) {\n    document.body.innerHTML = `<div class=\"user-error\">LINE ${lineNo}: ${text}</div>`;\n    throw new Error(text);\n  }\n  function hasLabelStartText(text) {\n    return text.startsWith(\"label\") || text.startsWith(\"l\");\n  }\n  const arithmeticCommands = {\n    set: (a, b) => b,\n    incr: (a, b) => a + b,\n    decr: (a, b) => a - b,\n    mult: (a, b) => a * b,\n    div: (a, b) => a / b,\n    round: (a, b) => Math.round(a),\n    floor: (a, b) => Math.floor(a)\n  };\n  function extractLabelAndCommandInfo(storyLines) {\n    const targetTable = {};\n    const commandTable = [];\n    function validateCommand(name, text, orgNo) {\n      if (name === \"goto\") {\n        const labelName = text;\n        if (!doesLabelExist(labelName)) {\n          userError(`\".goto ${labelName}\", but there is no label with name \"${labelName}\"`, orgNo);\n        }\n        return true;\n      }\n      if (arithmeticCommands[name]) {\n        return true;\n      }\n      return false;\n    }\n    function doesLabelExist(name) {\n      const index = getLabelIndex(name);\n      return index || index === 0;\n    }\n    function getLabelIndex(name) {\n      return targetTable[name];\n    }\n    function addLabel(index, name) {\n      name = name.toLowerCase();\n      targetTable[name] = index;\n    }\n    function addCommand(index, commandName, text, orgNo) {\n      commandTable[index] = {\n        name: commandName,\n        text\n      };\n      if (!validateCommand(commandName, text, orgNo)) {\n        userError(\n          `\".${commandName}\" is not a valid command. If you wanted to create a choice, put a space after the dot.`,\n          orgNo\n        );\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type === LineType.Undecided) {\n        if (!line.text.startsWith(\".\"))\n          continue;\n        const text = removeFirstChar(line.text);\n        if (hasLabelStartText(text)) {\n          const [_, name] = getFirstWordAndRest(text);\n          addLabel(line.index, name);\n          continue;\n        }\n      }\n    }\n    for (const line of storyLines) {\n      if (line.type !== LineType.Undecided || !line.text.startsWith(\".\"))\n        continue;\n      const text = removeFirstChar(line.text);\n      if (hasLabelStartText(text))\n        continue;\n      let [commandName, rest] = getFirstWordAndRest(text);\n      commandName = commandName.toLowerCase();\n      addCommand(line.index, commandName, rest, line.orgCodeLineNo);\n    }\n    return {\n      targetTable,\n      commandTable\n    };\n  }\n  class Runner {\n    constructor(storyLines, callbacks) {\n      __privateAdd(this, _checkIfCond);\n      __privateAdd(this, _isNextLineAChoice);\n      __privateAdd(this, _execCommand);\n      __privateAdd(this, _execChoice);\n      __privateAdd(this, _execText);\n      __privateAdd(this, _execLine);\n      __privateAdd(this, _lines, void 0);\n      __privateAdd(this, _targetTable, {});\n      __privateAdd(this, _commandTable, []);\n      __privateAdd(this, _linePointer, 0);\n      __privateAdd(this, _currentChoices, []);\n      __privateAdd(this, _callbacks, void 0);\n      __privateSet(this, _lines, storyLines);\n      const { targetTable, commandTable } = extractLabelAndCommandInfo(__privateGet(this, _lines));\n      __privateSet(this, _targetTable, targetTable);\n      __privateSet(this, _commandTable, commandTable);\n      __privateSet(this, _callbacks, callbacks);\n    }\n    restartStory() {\n      __privateSet(this, _linePointer, 0);\n      __privateSet(this, _currentChoices, []);\n    }\n    processNextLine() {\n      if (__privateGet(this, _currentChoices).length > 0 && !__privateMethod(this, _isNextLineAChoice, isNextLineAChoice_fn).call(this)) {\n        return {\n          type: ActionType.EndOfTurn,\n          text: \"\",\n          lineNo: -1\n        };\n      }\n      const { action, nextLine } = __privateMethod(this, _execLine, execLine_fn).call(this, __privateGet(this, _linePointer));\n      __privateSet(this, _linePointer, nextLine);\n      return action;\n    }\n    chooseChoice(index) {\n      const choice = __privateGet(this, _currentChoices)[index];\n      if (!choice) {\n        throw new Error(`Fatal: choice with index ${index} does not exist.`);\n      }\n      __privateSet(this, _currentChoices, []);\n      __privateSet(this, _linePointer, choice.index + 1);\n    }\n  }\n  _lines = new WeakMap();\n  _targetTable = new WeakMap();\n  _commandTable = new WeakMap();\n  _linePointer = new WeakMap();\n  _currentChoices = new WeakMap();\n  _callbacks = new WeakMap();\n  _checkIfCond = new WeakSet();\n  checkIfCond_fn = function(line) {\n    if (__privateGet(this, _callbacks).onCheckIfCond(\n      line.ifProps.left,\n      line.ifProps.operator,\n      line.ifProps.right\n    )) {\n      return line.index + 1;\n    } else {\n      return line.nextLineIndex;\n    }\n  };\n  _isNextLineAChoice = new WeakSet();\n  isNextLineAChoice_fn = function() {\n    var _a;\n    return !!(((_a = __privateGet(this, _lines)[__privateGet(this, _linePointer)]) == null ? void 0 : _a.type) === LineType.Choice);\n  };\n  _execCommand = new WeakSet();\n  execCommand_fn = function(command, index, line) {\n    if (command.name === \"goto\") {\n      const target = command.text.toLowerCase();\n      const nextLine = __privateGet(this, _targetTable)[target];\n      return {\n        nextLine,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    return {\n      nextLine: index + 1,\n      action: {\n        type: ActionType.Command,\n        text: command.text,\n        commandName: command.name,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n  };\n  _execChoice = new WeakSet();\n  execChoice_fn = function(line) {\n    const result = {\n      nextLine: line.nextLineIndex || line.index + 1,\n      action: {\n        type: ActionType.Choice,\n        text: line.text,\n        choiceIndex: __privateGet(this, _currentChoices).length,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n    __privateGet(this, _currentChoices).push(line);\n    return result;\n  };\n  _execText = new WeakSet();\n  execText_fn = function(line) {\n    return {\n      nextLine: line.nextLineIndex || line.index + 1,\n      action: {\n        type: ActionType.Text,\n        text: line.text,\n        lineNo: line == null ? void 0 : line.orgCodeLineNo\n      }\n    };\n  };\n  _execLine = new WeakSet();\n  execLine_fn = function(index) {\n    const line = __privateGet(this, _lines)[index];\n    if (!line) {\n      return {\n        nextLine: 0,\n        action: {\n          type: ActionType.StoryFlowRunsOut,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (__privateGet(this, _commandTable)[line.index]) {\n      return __privateMethod(this, _execCommand, execCommand_fn).call(this, __privateGet(this, _commandTable)[line.index], line.index, line);\n    }\n    if (line.isEnd) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.isElse) {\n      return {\n        nextLine: line.nextLineIndex,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.isIfCondition) {\n      const nextLine = __privateMethod(this, _checkIfCond, checkIfCond_fn).call(this, line);\n      return {\n        nextLine,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (line.type === LineType.Choice) {\n      return __privateMethod(this, _execChoice, execChoice_fn).call(this, line);\n    }\n    if (line.type === LineType.Gather) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    if (hasLabelStartText(removeFirstChar(line.text))) {\n      return {\n        nextLine: line.index + 1,\n        action: {\n          type: ActionType.Nothing,\n          text: \"\",\n          lineNo: line == null ? void 0 : line.orgCodeLineNo\n        }\n      };\n    }\n    return __privateMethod(this, _execText, execText_fn).call(this, line);\n  };\n  class Scheduler {\n    constructor(intervalTime = 50) {\n      __privateAdd(this, _tick);\n      __privateAdd(this, _execEvent);\n      __publicField(this, \"interval\");\n      __publicField(this, \"queue\", []);\n      __publicField(this, \"currentEvent\", null);\n      this.interval = window.setInterval(() => {\n        __privateMethod(this, _tick, tick_fn).call(this);\n      }, intervalTime);\n      __privateMethod(this, _tick, tick_fn).call(this);\n    }\n    addToQueue(execFunc, delay) {\n      let time = 0;\n      if (this.queue.length === 0) {\n        time = performance.now() + delay;\n      } else {\n        time = this.queue[this.queue.length - 1].time + delay;\n      }\n      performance.now();\n      this.queue.push({\n        execFunc,\n        time\n      });\n    }\n    flushQueue() {\n      this.queue = [];\n    }\n  }\n  _tick = new WeakSet();\n  tick_fn = function() {\n    if (this.queue.length === 0 && !this.currentEvent) {\n      return;\n    }\n    if (!this.currentEvent) {\n      this.currentEvent = this.queue.shift();\n    }\n    if (performance.now() >= this.currentEvent.time) {\n      __privateMethod(this, _execEvent, execEvent_fn).call(this, this.currentEvent);\n      this.currentEvent = null;\n    }\n  };\n  _execEvent = new WeakSet();\n  execEvent_fn = function(ev) {\n    ev.execFunc();\n  };\n  function customConfirm(title, msg, confirmButtonText, cancelButtonText, onConfirm, onCancel) {\n    const overlay = document.createElement(\"div\");\n    overlay.className = \"confirm-overlay show\";\n    const modal = document.createElement(\"div\");\n    modal.className = \"confirm-modal show\";\n    const titleEl = document.createElement(\"h2\");\n    titleEl.textContent = title;\n    const msgEl = document.createElement(\"p\");\n    msgEl.textContent = msg;\n    const buttonsContainer = document.createElement(\"div\");\n    buttonsContainer.className = \"confirm-buttons\";\n    const confirmBtn = document.createElement(\"button\");\n    confirmBtn.textContent = confirmButtonText;\n    confirmBtn.className = \"confirm-button\";\n    const cancelBtn = document.createElement(\"button\");\n    cancelBtn.textContent = cancelButtonText;\n    cancelBtn.className = \"cancel-button\";\n    const closeModal = (callback) => {\n      overlay.classList.remove(\"show\");\n      modal.classList.remove(\"show\");\n      overlay.classList.add(\"hide\");\n      modal.classList.add(\"hide\");\n      setTimeout(() => {\n        if (document.body.contains(overlay)) {\n          document.body.removeChild(overlay);\n        }\n        callback();\n      }, 300);\n    };\n    confirmBtn.onclick = () => closeModal(onConfirm);\n    cancelBtn.onclick = () => closeModal(onCancel);\n    buttonsContainer.appendChild(confirmBtn);\n    buttonsContainer.appendChild(cancelBtn);\n    modal.appendChild(titleEl);\n    modal.appendChild(msgEl);\n    modal.appendChild(buttonsContainer);\n    overlay.appendChild(modal);\n    document.body.appendChild(overlay);\n  }\n  const icons = {\n    //iconoir\n    hamburger: `data:image/svg+xml;utf8,` + encodeURIComponent(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><svg width=\"24px\" height=\"24px\" stroke-width=\"1.5\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" color=\"#000000\"><path d=\"M3 5H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M3 12H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path><path d=\"M3 19H21\" stroke=\"#000000\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`)\n  };\n  const story = window.$__$story;\n  for (const storyLine of story.kompilat.lines) {\n    Object.freeze(storyLine);\n  }\n  document.addEventListener(\"DOMContentLoaded\", startApp);\n  let settings = null;\n  let runner;\n  let scheduler;\n  let main;\n  let animations = true;\n  let menuOpen = false;\n  let menu;\n  let storyState = {\n    varMap: {}\n  };\n  function initTopBar() {\n    const topBar = document.getElementById(\"top-box\");\n    const button = document.createElement(\"button\");\n    const img = document.createElement(\"img\");\n    button.classList.add(\"menu-button\");\n    img.alt = \"menu\";\n    img.src = icons.hamburger;\n    button.append(img);\n    topBar.append(button);\n    button.addEventListener(\"click\", toggleMenu);\n    menu = document.createElement(\"div\");\n    menu.classList.add(\"menu\");\n    document.body.append(menu);\n    menu.innerHTML = `\n    <button id=\"menu-restart\">Restart</button>\n    <button id=\"menu-anims\">Animations On</button>\n    <button id=\"menu-theme\">Light</button>\n  `;\n    document.getElementById(\"menu-restart\").addEventListener(\"click\", () => {\n      requestRestart();\n    });\n    document.getElementById(\"menu-anims\").addEventListener(\"click\", () => {\n      toggleAnims();\n    });\n    document.getElementById(\"menu-theme\").addEventListener(\"click\", () => {\n      switchTheme();\n    });\n  }\n  function requestRestart() {\n    customConfirm(\n      i18n.rlyRestartTitle,\n      i18n.rlyRestartText,\n      i18n.rlyRestartOk,\n      i18n.rlyRestartCancel,\n      () => {\n      },\n      () => {\n      }\n    );\n  }\n  function toggleAnims() {\n    animations = !animations;\n    if (animations) {\n      enableAnims();\n    } else {\n      disableAnims();\n    }\n  }\n  function toggleMenu() {\n    menuOpen = !menuOpen;\n    if (menuOpen) {\n      menu.style.display = \"flex\";\n    } else {\n      menu.style.display = \"none\";\n    }\n  }\n  function startApp() {\n    const isExported = window.$__$isExportedStory;\n    initTopBar();\n    const metaData = story.kompilat.metaData || {};\n    settings = loadUserSettings();\n    setColors(metaData.color, metaData.theme, settings.theme);\n    if (metaData[\"debugfast\"] === \"yes\" && !isExported) {\n      disableAnims();\n    } else {\n      enableAnims();\n    }\n    const el = document.getElementById(\"app\");\n    if (!el)\n      throw new Error(\"DOM element with id #app not found.\");\n    main = el;\n    main = document.getElementById(\"main\");\n    initClickHandler();\n    runner = new Runner(story.kompilat.lines, { onCheckIfCond });\n    scheduler = new Scheduler(50);\n    runner.restartStory();\n    takeTurn(null, true);\n  }\n  function initClickHandler() {\n    document.body.addEventListener(\"click\", (e) => {\n      const el = e.target;\n      if (!el.classList.contains(\"choice\"))\n        return;\n      const index = Number(el.dataset.index);\n      if (Number.isNaN(index)) {\n        throw new Error(\"Fatal: choice: non-numeric index\");\n      }\n      clickOnChoice(index, el);\n    });\n  }\n  function endTheStory() {\n    console.log(\"Story ended: todo\");\n  }\n  function clickOnChoice(index, choiceButton) {\n    runner.chooseChoice(index);\n    takeTurn(choiceButton, false);\n  }\n  function dispatchText(el) {\n    const par = document.createElement(\"p\");\n    par.classList.add(\"story-paragraph\");\n    main.appendChild(par);\n    par.innerHTML = el.text;\n  }\n  function dispatchChoice(el) {\n    const choice = el;\n    const buttonPar = document.createElement(\"p\");\n    buttonPar.innerHTML = `\n      <button data-index=\"${choice.index}\"\n        class=\"choice\"\n      >\n        ${choice.text}\n      </button>`;\n    main.appendChild(buttonPar);\n  }\n  function mergeLinesIntoParagraphs(els) {\n    const nuEls = [];\n    let currentPar = null;\n    let insidePar = false;\n    for (const el of els) {\n      if (el.type === AbstractRenderElType.Text) {\n        if (el.text === \"\") {\n          insidePar = false;\n        } else {\n          if (insidePar) {\n            currentPar.text += el.text + \" \";\n          } else {\n            insidePar = true;\n            currentPar = {\n              type: AbstractRenderElType.Text,\n              text: el.text + \" \"\n            };\n            nuEls.push(currentPar);\n          }\n        }\n      } else {\n        nuEls.push(el);\n      }\n    }\n    return nuEls;\n  }\n  function disableAnims() {\n    document.body.classList.add(\"no-anims\");\n    animations = false;\n    document.getElementById(\"menu-anims\").innerHTML = i18n.animsOff;\n  }\n  function enableAnims() {\n    document.body.classList.remove(\"no-anims\");\n    animations = true;\n    document.getElementById(\"menu-anims\").innerHTML = i18n.animsOn;\n  }\n  function takeTurn(choiceButton, firstTurn) {\n    let els = callRunnerUntilNoMoreContent();\n    els = removeSomeEmptyLines(els);\n    const els2 = mergeLinesIntoParagraphs(els);\n    if (!firstTurn && animations) {\n      const others = Array.from(main.children).filter(\n        (el) => {\n          var _a;\n          return !((_a = el.children[0]) == null ? void 0 : _a.classList.contains(\"choice\"));\n        }\n      );\n      for (const other of Array.from(others)) {\n        other.classList.add(\"non-choice-out\");\n      }\n      const choices = document.querySelectorAll(\".choice\");\n      for (const ch of Array.from(choices)) {\n        const choice = ch;\n        choice.disabled = true;\n        const cls = choiceButton === choice ? \"selected-choice\" : \"discarded-choice\";\n        choice.classList.add(cls);\n      }\n      scheduler.addToQueue(() => {\n        main.innerHTML = \"\";\n      }, 700);\n    }\n    if (!animations) {\n      main.innerHTML = \"\";\n    }\n    let i = -1;\n    for (const el of els2) {\n      i++;\n      if (el.type === AbstractRenderElType.Text) {\n        if (el.text === \"\")\n          continue;\n        const func = () => dispatchText(el);\n        if (animations) {\n          scheduler.addToQueue(func, i === 0 ? 0 : 200);\n        } else {\n          func();\n        }\n      } else if (el.type === AbstractRenderElType.Choice) {\n        const func = () => dispatchChoice(el);\n        if (animations) {\n          scheduler.addToQueue(func, i === 0 ? 0 : 200);\n        } else {\n          func();\n        }\n      }\n    }\n  }\n  function removeSomeEmptyLines(els) {\n    const nuEls = [];\n    let prevLineWasEmpty = false;\n    let firstNonEmptyLineEncountered = false;\n    for (const el of els) {\n      if (el.type === AbstractRenderElType.Text && el.text === \"\") {\n        if (!firstNonEmptyLineEncountered)\n          continue;\n        if (prevLineWasEmpty)\n          continue;\n        prevLineWasEmpty = true;\n        nuEls.push(el);\n      } else {\n        firstNonEmptyLineEncountered = true;\n        prevLineWasEmpty = false;\n        nuEls.push(el);\n      }\n    }\n    while (true) {\n      const last = nuEls[nuEls.length - 1];\n      if (!last)\n        break;\n      if (last.type === AbstractRenderElType.Text && last.text === \"\") {\n        nuEls.pop();\n      } else {\n        break;\n      }\n    }\n    return nuEls;\n  }\n  function dispatchArithmetic(action, arithFunc) {\n    const text = action.text;\n    action.lineNo;\n    let [varName, rest] = getFirstWordAndRest(text);\n    rest = rest.trim();\n    if (isFiniteNumber(rest)) {\n      dispatchVarEventArithmetic(varName, Number(rest), action.lineNo, arithFunc);\n      return;\n    }\n    if (rest.startsWith('\"')) {\n      if (!rest.endsWith('\"')) {\n        userError(`Text string must end with \"`, action.lineNo);\n      }\n      rest = rest.substring(1, rest.length - 1);\n      dispatchVarEventArithmetic(varName, rest, action.lineNo, arithFunc);\n      return;\n    }\n    dispatchVarEventArithmetic(\n      varName,\n      varGetValue(rest),\n      action.lineNo,\n      arithFunc\n    );\n  }\n  function getVarOrNumberVal(str) {\n    if (isFiniteNumber(str))\n      return Number(str);\n    return varGetValue(str);\n  }\n  function onCheckIfCond(left, operator, right) {\n    let leftE = getVarOrNumberVal(left);\n    let rightE = getVarOrNumberVal(right);\n    if (operator === \"=\")\n      return leftE === rightE;\n    if (operator === \">\")\n      return leftE > rightE;\n    if (operator === \"<\")\n      return leftE < rightE;\n    if (operator === \">=\")\n      return leftE >= rightE;\n    if (operator === \"<=\")\n      return leftE <= rightE;\n    if (operator === \"!=\" || operator === \"<>\")\n      return leftE !== rightE;\n    throw new Error(`Invaid operator. Should not happen.`);\n  }\n  function varGetValue(varName) {\n    varName = varName.toLowerCase();\n    const val = storyState.varMap[varName];\n    return val;\n  }\n  function varSetValue(varName, newVal, lineNo) {\n    varName = varName.toLowerCase();\n    storyState.varMap[varName] = newVal;\n    console.log(`I SET VAR ${varName} to ${newVal}`);\n  }\n  function dispatchVarEventArithmetic(varName, val, lineNo, arithFunc) {\n    const oldValue = varGetValue(varName);\n    const result = arithFunc(oldValue, val);\n    varSetValue(varName, result);\n  }\n  function isFiniteNumber(value) {\n    const num = Number(value);\n    return Number.isFinite(num);\n  }\n  function dispatchCommand(action) {\n    if (arithmeticCommands[action.commandName]) {\n      dispatchArithmetic(action, arithmeticCommands[action.commandName]);\n      return;\n    }\n  }\n  function callRunnerUntilNoMoreContent() {\n    function addEl(el) {\n      els.push(el);\n    }\n    let safeGuard = 0;\n    const els = [];\n    while (true) {\n      safeGuard++;\n      if (safeGuard >= 2e4) {\n        userError(\"Endless loop?\", -1);\n      }\n      const action = runner.processNextLine();\n      if (action.type === ActionType.EndOfTurn) {\n        break;\n      }\n      if (action.type === ActionType.StoryFlowRunsOut) {\n        console.log(\"Reached end of script\");\n        endTheStory();\n        break;\n      }\n      if (action.type === ActionType.Nothing) {\n        continue;\n      }\n      if (action.type === ActionType.Command) {\n        dispatchCommand(action);\n        continue;\n      }\n      if (action.type === ActionType.Choice) {\n        addEl({\n          type: AbstractRenderElType.Choice,\n          text: action.text,\n          index: action.choiceIndex\n        });\n        continue;\n      }\n      if (action.type === ActionType.Text) {\n        addEl({\n          type: AbstractRenderElType.Text,\n          text: action.text\n        });\n        continue;\n      }\n    }\n    return els;\n  }\n})();\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  function userError(text, lineNo) {\n    document.body.innerHTML = `<div class=\"user-error\">LINE ${lineNo}: ${text}</div>`;\n    throw new Error(text);\n  }\n  exports.userError = userError;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n\nvar $$__engX082398 = function(exports) {\n  \"use strict\";\n  function getFirstWordAndRest(str) {\n    const index = str.search(/\\s/);\n    if (index === -1)\n      return [str.trim(), \"\"];\n    return [str.slice(0, index).trim(), str.slice(index + 1).trim()];\n  }\n  function removeFirstChar(str) {\n    return str.slice(1);\n  }\n  exports.getFirstWordAndRest = getFirstWordAndRest;\n  exports.removeFirstChar = removeFirstChar;\n  Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" });\n  return exports;\n}({});\n","files":{"animation-killer.css":"\n.no-anims, .no-anims * {\n  animation: none !important;\n  transition: none !important;\n  scroll-behavior: auto !important;\n}\n","confirm.css":".confirm-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: var(--bg);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 0;\n  transition: opacity 0.3s ease, background-color 0.3s ease;\n  z-index: 9999;\n}\n\n.confirm-overlay.show {\n  background-color: rgba(0, 0, 0, 0.5);\n  opacity: 1;\n}\n\n.confirm-overlay.hide {\n  opacity: 0;\n  background-color: rgba(0, 0, 0, 0);\n}\n\n.confirm-modal {\n  background: var(--bg);\n  border-radius: 10px;\n  padding: 20px;\n  max-width: 400px;\n  width: 80%;\n  text-align: center;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);\n  transform: translateY(-20px);\n  opacity: 0;\n  transition: opacity 0.3s ease, transform 0.3s ease;\n}\n\n.confirm-modal.show {\n  transform: translateY(0);\n  opacity: 1;\n}\n\n.confirm-modal.hide {\n  transform: translateY(-20px);\n  opacity: 0;\n}\n\n.confirm-buttons {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n  gap: 10px;\n}\n\n.confirm-button {\n  background-color: var(--bg);\n  color: var(--text);\n  border: 4px solid var(--accent);\n  padding: 8px 16px;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.cancel-button {\n  background-color: var(--bg);\n  color: var(--text);\n  border: 4px solid var(--text);\n  padding: 8px 16px;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.confirm-button:hover {\n  opacity: 0.85;\n}\n\n.cancel-button:hover {\n  opacity: 0.85;\n}\n","index.html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n  <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\">\n</head>\n\n<body>\n  <div id=\"app\">\n    <div id=\"wrapper\">\n      <div id=\"top-box\">\n      </div>\n      <div id=\"main\"></div>\n      <div id=\"bottom-box\"></div>\n    </div>\n  </div>\n</body>\n</html>","resets.css":"\nbutton {\n  /* CSS sucks, so this is needed so that disabled choices\n  do not appear with opacity and we apply it even to\n  buttons that are not disabled, so we can style choices uniformly. */\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  opacity: 1;\n  cursor: default;\n  color: inherit;\n  background: inherit;\n  border: inherit;\n}","style.css":"\n\n* {\n    box-sizing: border-box;\n}\n\n\n:root {\n  --accent: #d00;\n  --text: #000;\n  --bg: #fff;\n  --top-box-height: 32px;\n  --bottom-box-height: 24px;\n}\n\n\nbody {\n  margin: 0px;\n  background-color: var(--bg);\n  color: var(--text);\n}\n\n\n.user-error {\n  border: 4px solid #d00;\n  padding: 12px;\n}\n\n\n#app {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n\n\n.wrapper-box {\n}\n\n\n#top-box {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100vw;\n  height: var(--top-box-height);\n  display: flex;\n  align-items: center;\n}\n\n#main {\n  position: absolute;\n  left: 0;\n  top: var(--top-box-height);\n  width: 100vw;\n  height: calc(100vh - var(--top-box-height) - var(--bottom-box-height));\n  overflow: hidden;\n  padding: 8px;\n}\n\n#bottom-box {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  width: 100vw;\n  height: var(--bottom-box-height);\n}\n\n\n.choice {\n  animation: slideInRight 0.5s forwards;\n  border: 4px solid var(--text);\n  padding: 12px;\n  cursor: pointer;\n  transform-origin: center;\n  transform: scaleY(1); \n}\n\n\n.story-paragraph {\n  animation: slideInRight 0.5s forwards;\n}\n\n\n.trans-out-element {\n  animation: slideOutLeft 0.6s forwards;\n}\n\n\n.discarded-choice {\n  animation: discardedChoiceAnim 0.6s forwards;\n}\n\n\n.selected-choice {\n  animation: selectedChoiceAnim 0.69s forwards;\n}\n\n\n.non-choice-out {\n  animation: slideOutLeft 0.6s forwards;\n}\n\n\n@keyframes slideOutLeft {\n  from {\n    transform: translateX(0);\n    opacity: 1;\n  }\n  to {\n    transform: translateX(-100%);\n    opacity: 0;\n  }\n}\n\n\n@keyframes slideInRight {\n  from {\n    transform: translateX(100%);\n    opacity: 0;\n  }\n  to {\n    transform: translateX(0);\n    opacity: 1;\n  }\n}\n\n\n@keyframes selectedChoiceAnim {\n  0% {\n    opacity: 1;\n    border-color: var(--text);\n  }\n\n  50% {\n    opacity: 1;\n    border-color: var(--accent);\n  }\n\n  100% {\n    opacity: 0;\n    border-color: var(--accent);\n  }\n}\n\n\n@keyframes discardedChoiceAnim {\n  0% {\n    opacity: 1;\n    transform: scaleY(1); \n  }\n\n  100% {\n    opacity: 0;\n    transform: scaleY(0); \n  }\n}\n\n.menu-button {\n  width: 24px;\n  height: 24px;\n}\n\n\n.menu {\n  position: absolute;\n  left: 0;\n  top: var(--top-box-height);\n  width: 100vw;\n  height: calc(100vh - var(--top-box-height));\n  overflow: auto;\n  z-index: 9000;\n  background: var(--bg);\n  color: var(--text);\n  display: none;\n  flex-direction: column;\n}\n\n\n.menu button {\n  margin-top: 24px;\n  font-size: 18px;\n}\n\n\nbody.dark .menu-button {\n  filter: invert(1);\n}\n\n"}}